# 开场
各位评委老师，同学，大家好。

我们团队这次开发的项目的题目是基于图像处理的恶意代码检测，项目的介绍主要就是从我们开始确定主题，然后调研，设计，最后实现并完善的流程来进行。

# 背景&意义
最开始，我们团队几个人想出了许多不同的主题，包括基于人体生物特征的身份识别，语音识别诈骗电话，大数据时代的个人信息防护，以及我们做的恶意代码检测等等。最后确定这个题目，是因为一个偶然的机会我们在网上看到一个新闻，2016年4月26日德国的核电站因检测出恶意程序被迫关闭，而时间也正好是切尔诺贝利核电站事故30周年。并且了解到，每天大概有31万种新的恶意程序出现，其中很多就能够对系统造成破坏，从而对人的财产甚至生命安全造成严重威胁。所以，与其设计一个功能性软件，不如真正在对抗恶意程序代码上尽自己的一份力量。

# 现状
在确定了主题之后，我们就开始搜集当前主流的恶意代码检测方法，结果发现，主要分为两种：动态检测和静态检测。首先是动态检测，所谓动态检测，顾名思义，就是动态运行目标程序，观测程序的行为从而判断是否是包含恶意代码，这种方法的主要缺点就是效率比较低，对系统运行负荷较高。和动态检测不同，静态检测则不需要运行程序，而是通过判断代码的特征是否符合恶意代码的特征来判断是否是恶意代码，但是目前的静态检测还是存在一个严重的缺点，就是特征更新的滞后性。

针对这些不足，我们开发了我们的基于图像处理的恶意代码检测系统。

# 实现方案
我们的整个设计方案主要分为四部分，程序的输入是待检测的可执行程序，输出是和恶意代码匹配的匹配率。

## 反汇编
首先，如果我们直接分析二进制代码，是很难发现或者寻找出代码的关键部分的，因为其中参杂很多无关的代码，所以我们选择先对可执行程序进行反汇编，而反汇编我们主要是参考网上一个反汇编引擎，并稍加调试修改，变成符合我们自己的版本，从而方便执行后续的操作。

## 去除混淆代码
前面已经讲到，在可执行程序当中充斥着许多无关的代码，这些无关代码从来源上讲主要包括编译器自动产生的，空指令，以及人为添加的，而正是这些无关代码的加入，增添了我们寻找关键代码特征的难度。我们通过调研发现，网上有各种各样的混淆技术，而对于如何去掉混淆代码从而还原出源代码却乏善可陈。由于自身技术的限制加上网上缺乏这方面资料，我们只针对两种混淆技术进行处理：添加dead-code和jmp跳转。

dead-code:程序运行过程中永远不会执行的部分。
jmp跳转：通过添加jmp语句，打乱原来的代码顺序结构。

代码块：一段连续的代码有且仅有一个跳转语句，且位于这段代码的最后一行。

首先，从程序入口点开始，这个入口点可以从PE的头部提取出来，以深度优先搜索(DFS)的方式不断寻找新的代码块，并且将所有访问到的块连接起来构成一张图，图中每一个节点就是一个代码块，这样我们就可以标记出代码运行是所有访问过的块，而那些没有标记的块我们就可以当做是无关的代码，从而去掉这些混淆的代码。

## 代码转为灰度图像
去掉混淆的代码之后，如何寻找恶意代码的特征就成为关键。在查找相关资料时，偶然发现一种全新的思路展现在我们眼前，那就是先将代码转化为图像，然后利用现有成熟的图像分析技术来寻找恶意代码的特征。那么如何将代码转化为图像呢？我们知道，文件在磁盘上存储的实际上都是二进制的形式，而一个像素对应的刚好是一个字节(0~255)，那么我们就可以以字节的形式来读取文件，从而每个字节就对应了一个像素，这样就可以得到代码的图像了。

## 图像匹配
将代码转化为图像之后，我们需要做的就是选择相应的图像匹配算法，从而能够将待检测的代码图像和恶意代码图像库进行比较，进而根据匹配程度判断待检测的代码是否是某种恶意代码或者其变种。

选择利用代码图像特征的好处是可以检测恶意代码的变种，而不是像传统的特征码那么的单一。

# 创新点
我们项目的创新点主要有三个方面，
* 去混淆处理，包括dead-code和jmp跳转
* 利用恶意代码图像特征不仅可以用于检测，还可以利用匹配相似度来进行恶意代码聚类分析
* 通过集中常用图像匹配算法的对比，我们发现surf算法更适用于分析恶意代码的图像特征

# 功能测试
我们功能的演示主要分为三个部分来进行，
* 反汇编去混淆
* 转化为灰度图像
* 图像匹配

# 总结
总体来说，虽然我们的软件在功能上有很多的缺陷，但是无论是从去除混淆代码的影响，还是从恶意代码图像分析上来说，我们都为恶意代码的检测提供了一种新的思路，并且具有自己独特的优点，我们也始终期待着一个高效，准确的检测方案早日被提出来，从而减少恶意代码对人们生产生活的威胁。
